const axios = require("axios"); const fs = require("fs"); const path = require("path"); const ytSearch = require("yt-search"); module.exports = { config: { name: "music", version: "2.0.1", hasPermssion: 0, credits: "ùêèùê´ùê¢ùê≤ùêöùêßùê¨ùê° ùêëùêöùê£ùê©ùêÆùê≠", description: "Download YouTube song from keyword search or link (m4a for audio, 360p for video)", commandCategory: "Media", usages: "[songName] [audio/video]", cooldowns: 5, dependencies: { "node-fetch": "", "yt-search": "", }, }, run: async function ({ api, event, args }) { let songName, type; if ( args.length > 1 && (args[args.length - 1] === "audio" || args[args.length - 1] === "video") ) { type = args.pop(); songName = args.join(" "); } else { songName = args.join(" "); type = "audio"; } const processingMessage = await api.sendMessage( "‚úÖ Apki Request. Please wait...", event.threadID, null, event.messageID ); try { if (!songName || songName.trim().length === 0) { throw new Error("Please provide a search term or YouTube link."); } // If user passed a full YouTube link, prefer that; otherwise search let videoUrl = ""; const ytMatch = songName.match(/(https?:\/\/)?(www\.)?(youtube\.com|youtu\.be)\/\S+/i); if (ytMatch) { // user gave a link directly videoUrl = songName.trim(); } else { // search via yt-search const searchResults = await ytSearch(songName); if (!searchResults || !searchResults.videos.length) { throw new Error("No results found for your search query."); } const topResult = searchResults.videos[0]; videoUrl = `https://youtube.com/watch?v=${topResult.videoId}`; } // POST to new API endpoint (format param is unreliable -> we ignore it) const apiUrl = "https://priyanshuapi.xyz/api/runner/youtube-downloader/download"; const headers = { Authorization: "Bearer apim_FGQiSaxP3fwJ-zAUSwLNaNl522Ri83elWNCNWeUVZzE", "Content-Type": "application/json", }; api.setMessageReaction("‚åõ", event.messageID, () => {}, true); const apiResp = await axios.post(apiUrl, { url: videoUrl }, { headers }); if (!apiResp || !apiResp.data) { throw new Error("Empty response from downloader API."); } const body = apiResp.data; if (!body.success || !body.data || !Array.isArray(body.data.items)) { throw new Error( `Downloader API error: ${body && body.message ? body.message : "unexpected response"}` ); } const items = body.data.items; // Find audio (M4A AAC) or video (360p) link from items array let chosenItem; if (type === "audio") { // pick first item whose quality mentions "M4A" or "AAC" or whose label is "AAC" chosenItem = items.find((it) => { const q = (it.quality || "").toLowerCase(); const label = (it.label || "").toLowerCase(); return q.includes("m4a") || q.includes("aac") || label.includes("aac") || q.includes("m4a aac"); }); } else { // pick first item whose quality includes "360p" (case-insensitive) chosenItem = items.find((it) => { const q = (it.quality || "").toLowerCase(); return q.includes("360p") || (it.size && it.size.toString().includes("11.6MB")); // fallback not necessary but harmless }); } if (!chosenItem || !chosenItem.url) { // Provide helpful debug info in error const available = items.map((it) => `${it.quality || "unknown"} (${it.size || "n/a"})`).join(", "); throw new Error(`Requested format not found. Available: ${available}`); } const downloadUrl = chosenItem.url; // Prepare filename & path // If we searched, we have top result title from ytSearch. If user provided link, fetch title from items/source fallback. let safeTitle = "download"; try { if (!ytMatch) { // we used ytSearch earlier; reuse top result title const sr = await ytSearch(songName); if (sr && sr.videos && sr.videos[0]) safeTitle = sr.videos[0].title; } else { // user provided a link ‚Äî try to use body.data.source or fallback to URL id safeTitle = body.data.source || videoUrl; } } catch (e) { safeTitle = videoUrl; } safeTitle = (safeTitle || "download").replace(/[^a-zA-Z0-9 \-_\.]/g, "").trim(); const ext = type === "audio" ? "m4a" : "mp4"; const filename = `${safeTitle || "file"}.${ext}`; const downloadPath = path.join(__dirname, "cache", filename); if (!fs.existsSync(path.dirname(downloadPath))) { fs.mkdirSync(path.dirname(downloadPath), { recursive: true }); } // Stream download const streamResp = await axios({ url: downloadUrl, method: "GET", responseType: "stream", timeout: 120000, maxContentLength: Infinity, maxBodyLength: Infinity, }); const writer = fs.createWriteStream(downloadPath); streamResp.data.pipe(writer); await new Promise((resolve, reject) => { writer.on("finish", resolve); writer.on("error", reject); }); api.setMessageReaction("‚úÖ", event.messageID, () => {}, true); // Send file await api.sendMessage( { body: `üñ§ Title: ${safeTitle}\nüîä Type: ${type}\nüì¶ Size: ${chosenItem.size || "unknown"}`, attachment: fs.createReadStream(downloadPath), }, event.threadID, async () => { try { if (fs.existsSync(downloadPath)) fs.unlinkSync(downloadPath); if (processingMessage && processingMessage.messageID) await api.unsendMessage(processingMessage.messageID); } catch (e) { // ignore cleanup errors console.warn("Cleanup warning:", e.message); } }, event.messageID ); } catch (error) { console.error("Failed to download and send:", error && error.message ? error.message : error); try { await api.sendMessage( `‚ùå Failed to download: ${error && error.message ? error.message : "Unknown error"}`, event.threadID, event.messageID ); if (processingMessage && processingMessage.messageID) { await api.unsendMessage(processingMessage.messageID); } } catch (e) { console.warn("Failed to send error message:", e.message); } } }, };